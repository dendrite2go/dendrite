// Code generated by protoc-gen-go. DO NOT EDIT.
// source: event.proto

package axon_server

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Request message to receive the first Token (Tail Token) of the Event Stream
type GetFirstTokenRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetFirstTokenRequest) Reset()         { *m = GetFirstTokenRequest{} }
func (m *GetFirstTokenRequest) String() string { return proto.CompactTextString(m) }
func (*GetFirstTokenRequest) ProtoMessage()    {}
func (*GetFirstTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{0}
}

func (m *GetFirstTokenRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetFirstTokenRequest.Unmarshal(m, b)
}
func (m *GetFirstTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetFirstTokenRequest.Marshal(b, m, deterministic)
}
func (m *GetFirstTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFirstTokenRequest.Merge(m, src)
}
func (m *GetFirstTokenRequest) XXX_Size() int {
	return xxx_messageInfo_GetFirstTokenRequest.Size(m)
}
func (m *GetFirstTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFirstTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetFirstTokenRequest proto.InternalMessageInfo

// Request message to receive the last Token (Head Token) of the Event Stream
type GetLastTokenRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLastTokenRequest) Reset()         { *m = GetLastTokenRequest{} }
func (m *GetLastTokenRequest) String() string { return proto.CompactTextString(m) }
func (*GetLastTokenRequest) ProtoMessage()    {}
func (*GetLastTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{1}
}

func (m *GetLastTokenRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLastTokenRequest.Unmarshal(m, b)
}
func (m *GetLastTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLastTokenRequest.Marshal(b, m, deterministic)
}
func (m *GetLastTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLastTokenRequest.Merge(m, src)
}
func (m *GetLastTokenRequest) XXX_Size() int {
	return xxx_messageInfo_GetLastTokenRequest.Size(m)
}
func (m *GetLastTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLastTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLastTokenRequest proto.InternalMessageInfo

// Request message to receive the Token that starts streaming events from the given timestamp
type GetTokenAtRequest struct {
	// Timestamp expressed as milliseconds since epoch
	Instant              int64    `protobuf:"varint,1,opt,name=instant,proto3" json:"instant,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTokenAtRequest) Reset()         { *m = GetTokenAtRequest{} }
func (m *GetTokenAtRequest) String() string { return proto.CompactTextString(m) }
func (*GetTokenAtRequest) ProtoMessage()    {}
func (*GetTokenAtRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{2}
}

func (m *GetTokenAtRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetTokenAtRequest.Unmarshal(m, b)
}
func (m *GetTokenAtRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetTokenAtRequest.Marshal(b, m, deterministic)
}
func (m *GetTokenAtRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTokenAtRequest.Merge(m, src)
}
func (m *GetTokenAtRequest) XXX_Size() int {
	return xxx_messageInfo_GetTokenAtRequest.Size(m)
}
func (m *GetTokenAtRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTokenAtRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTokenAtRequest proto.InternalMessageInfo

func (m *GetTokenAtRequest) GetInstant() int64 {
	if m != nil {
		return m.Instant
	}
	return 0
}

// Message containing the information necessary to track the position of events in the Event Stream
type TrackingToken struct {
	// The value of the Token
	Token                int64    `protobuf:"varint,1,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TrackingToken) Reset()         { *m = TrackingToken{} }
func (m *TrackingToken) String() string { return proto.CompactTextString(m) }
func (*TrackingToken) ProtoMessage()    {}
func (*TrackingToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{3}
}

func (m *TrackingToken) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TrackingToken.Unmarshal(m, b)
}
func (m *TrackingToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TrackingToken.Marshal(b, m, deterministic)
}
func (m *TrackingToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackingToken.Merge(m, src)
}
func (m *TrackingToken) XXX_Size() int {
	return xxx_messageInfo_TrackingToken.Size(m)
}
func (m *TrackingToken) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackingToken.DiscardUnknown(m)
}

var xxx_messageInfo_TrackingToken proto.InternalMessageInfo

func (m *TrackingToken) GetToken() int64 {
	if m != nil {
		return m.Token
	}
	return 0
}

// Message wrapping an Event and a Tracking Token
type EventWithToken struct {
	// The Token representing the position of this Event in the Stream
	Token int64 `protobuf:"varint,1,opt,name=token,proto3" json:"token,omitempty"`
	// The actual Event Message
	Event                *Event   `protobuf:"bytes,2,opt,name=event,proto3" json:"event,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventWithToken) Reset()         { *m = EventWithToken{} }
func (m *EventWithToken) String() string { return proto.CompactTextString(m) }
func (*EventWithToken) ProtoMessage()    {}
func (*EventWithToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{4}
}

func (m *EventWithToken) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventWithToken.Unmarshal(m, b)
}
func (m *EventWithToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventWithToken.Marshal(b, m, deterministic)
}
func (m *EventWithToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventWithToken.Merge(m, src)
}
func (m *EventWithToken) XXX_Size() int {
	return xxx_messageInfo_EventWithToken.Size(m)
}
func (m *EventWithToken) XXX_DiscardUnknown() {
	xxx_messageInfo_EventWithToken.DiscardUnknown(m)
}

var xxx_messageInfo_EventWithToken proto.InternalMessageInfo

func (m *EventWithToken) GetToken() int64 {
	if m != nil {
		return m.Token
	}
	return 0
}

func (m *EventWithToken) GetEvent() *Event {
	if m != nil {
		return m.Event
	}
	return nil
}

// Message providing the parameters for executing a Query against AxonServer.
type QueryEventsRequest struct {
	// The query to execute against the Event Stream
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	// The number of results AxonServer may send before new permits need to be provided
	NumberOfPermits int64 `protobuf:"varint,2,opt,name=number_of_permits,json=numberOfPermits,proto3" json:"number_of_permits,omitempty"`
	// Whether to keep the query running against incoming events once the Head of the Stream is reached
	LiveEvents           bool     `protobuf:"varint,3,opt,name=live_events,json=liveEvents,proto3" json:"live_events,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryEventsRequest) Reset()         { *m = QueryEventsRequest{} }
func (m *QueryEventsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryEventsRequest) ProtoMessage()    {}
func (*QueryEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{5}
}

func (m *QueryEventsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryEventsRequest.Unmarshal(m, b)
}
func (m *QueryEventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryEventsRequest.Marshal(b, m, deterministic)
}
func (m *QueryEventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryEventsRequest.Merge(m, src)
}
func (m *QueryEventsRequest) XXX_Size() int {
	return xxx_messageInfo_QueryEventsRequest.Size(m)
}
func (m *QueryEventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryEventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryEventsRequest proto.InternalMessageInfo

func (m *QueryEventsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *QueryEventsRequest) GetNumberOfPermits() int64 {
	if m != nil {
		return m.NumberOfPermits
	}
	return 0
}

func (m *QueryEventsRequest) GetLiveEvents() bool {
	if m != nil {
		return m.LiveEvents
	}
	return false
}

// A message describing a response to a Query request
type QueryEventsResponse struct {
	// The actual contents of this response
	//
	// Types that are valid to be assigned to Data:
	//	*QueryEventsResponse_Columns
	//	*QueryEventsResponse_Row
	//	*QueryEventsResponse_FilesCompleted
	Data                 isQueryEventsResponse_Data `protobuf_oneof:"data"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *QueryEventsResponse) Reset()         { *m = QueryEventsResponse{} }
func (m *QueryEventsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryEventsResponse) ProtoMessage()    {}
func (*QueryEventsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{6}
}

func (m *QueryEventsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryEventsResponse.Unmarshal(m, b)
}
func (m *QueryEventsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryEventsResponse.Marshal(b, m, deterministic)
}
func (m *QueryEventsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryEventsResponse.Merge(m, src)
}
func (m *QueryEventsResponse) XXX_Size() int {
	return xxx_messageInfo_QueryEventsResponse.Size(m)
}
func (m *QueryEventsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryEventsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryEventsResponse proto.InternalMessageInfo

type isQueryEventsResponse_Data interface {
	isQueryEventsResponse_Data()
}

type QueryEventsResponse_Columns struct {
	Columns *ColumnsResponse `protobuf:"bytes,1,opt,name=columns,proto3,oneof"`
}

type QueryEventsResponse_Row struct {
	Row *RowResponse `protobuf:"bytes,2,opt,name=row,proto3,oneof"`
}

type QueryEventsResponse_FilesCompleted struct {
	FilesCompleted *Confirmation `protobuf:"bytes,3,opt,name=files_completed,json=filesCompleted,proto3,oneof"`
}

func (*QueryEventsResponse_Columns) isQueryEventsResponse_Data() {}

func (*QueryEventsResponse_Row) isQueryEventsResponse_Data() {}

func (*QueryEventsResponse_FilesCompleted) isQueryEventsResponse_Data() {}

func (m *QueryEventsResponse) GetData() isQueryEventsResponse_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *QueryEventsResponse) GetColumns() *ColumnsResponse {
	if x, ok := m.GetData().(*QueryEventsResponse_Columns); ok {
		return x.Columns
	}
	return nil
}

func (m *QueryEventsResponse) GetRow() *RowResponse {
	if x, ok := m.GetData().(*QueryEventsResponse_Row); ok {
		return x.Row
	}
	return nil
}

func (m *QueryEventsResponse) GetFilesCompleted() *Confirmation {
	if x, ok := m.GetData().(*QueryEventsResponse_FilesCompleted); ok {
		return x.FilesCompleted
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*QueryEventsResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*QueryEventsResponse_Columns)(nil),
		(*QueryEventsResponse_Row)(nil),
		(*QueryEventsResponse_FilesCompleted)(nil),
	}
}

// Message containing the names of the columns returned in a Query
type ColumnsResponse struct {
	// The names of the columns provided in the query
	Column               []string `protobuf:"bytes,1,rep,name=column,proto3" json:"column,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColumnsResponse) Reset()         { *m = ColumnsResponse{} }
func (m *ColumnsResponse) String() string { return proto.CompactTextString(m) }
func (*ColumnsResponse) ProtoMessage()    {}
func (*ColumnsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{7}
}

func (m *ColumnsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ColumnsResponse.Unmarshal(m, b)
}
func (m *ColumnsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ColumnsResponse.Marshal(b, m, deterministic)
}
func (m *ColumnsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnsResponse.Merge(m, src)
}
func (m *ColumnsResponse) XXX_Size() int {
	return xxx_messageInfo_ColumnsResponse.Size(m)
}
func (m *ColumnsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnsResponse proto.InternalMessageInfo

func (m *ColumnsResponse) GetColumn() []string {
	if m != nil {
		return m.Column
	}
	return nil
}

// Message providing Query Result data
type RowResponse struct {
	// The values which, when combined, uniquely update this row. Any previously received values with the same identifiers should be replaced with this value
	IdValues []*QueryValue `protobuf:"bytes,1,rep,name=id_values,json=idValues,proto3" json:"id_values,omitempty"`
	// The sorting values to use when sorting this response compared to the others.
	SortValues []*QueryValue `protobuf:"bytes,2,rep,name=sort_values,json=sortValues,proto3" json:"sort_values,omitempty"`
	// The actual data values for each of the columns, as a column name -> value mapping
	Values               map[string]*QueryValue `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *RowResponse) Reset()         { *m = RowResponse{} }
func (m *RowResponse) String() string { return proto.CompactTextString(m) }
func (*RowResponse) ProtoMessage()    {}
func (*RowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{8}
}

func (m *RowResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RowResponse.Unmarshal(m, b)
}
func (m *RowResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RowResponse.Marshal(b, m, deterministic)
}
func (m *RowResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowResponse.Merge(m, src)
}
func (m *RowResponse) XXX_Size() int {
	return xxx_messageInfo_RowResponse.Size(m)
}
func (m *RowResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RowResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RowResponse proto.InternalMessageInfo

func (m *RowResponse) GetIdValues() []*QueryValue {
	if m != nil {
		return m.IdValues
	}
	return nil
}

func (m *RowResponse) GetSortValues() []*QueryValue {
	if m != nil {
		return m.SortValues
	}
	return nil
}

func (m *RowResponse) GetValues() map[string]*QueryValue {
	if m != nil {
		return m.Values
	}
	return nil
}

// Describes the combination of an Aggregate Identifier and first expected Sequence number when opening an Aggregate-specific Event Stream
type ReadHighestSequenceNrRequest struct {
	// The Identifier of the Aggregate for which to load events
	AggregateId string `protobuf:"bytes,1,opt,name=aggregate_id,json=aggregateId,proto3" json:"aggregate_id,omitempty"`
	// The Sequence Number of the first event expected
	FromSequenceNr       int64    `protobuf:"varint,3,opt,name=from_sequence_nr,json=fromSequenceNr,proto3" json:"from_sequence_nr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadHighestSequenceNrRequest) Reset()         { *m = ReadHighestSequenceNrRequest{} }
func (m *ReadHighestSequenceNrRequest) String() string { return proto.CompactTextString(m) }
func (*ReadHighestSequenceNrRequest) ProtoMessage()    {}
func (*ReadHighestSequenceNrRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{9}
}

func (m *ReadHighestSequenceNrRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadHighestSequenceNrRequest.Unmarshal(m, b)
}
func (m *ReadHighestSequenceNrRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadHighestSequenceNrRequest.Marshal(b, m, deterministic)
}
func (m *ReadHighestSequenceNrRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadHighestSequenceNrRequest.Merge(m, src)
}
func (m *ReadHighestSequenceNrRequest) XXX_Size() int {
	return xxx_messageInfo_ReadHighestSequenceNrRequest.Size(m)
}
func (m *ReadHighestSequenceNrRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadHighestSequenceNrRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadHighestSequenceNrRequest proto.InternalMessageInfo

func (m *ReadHighestSequenceNrRequest) GetAggregateId() string {
	if m != nil {
		return m.AggregateId
	}
	return ""
}

func (m *ReadHighestSequenceNrRequest) GetFromSequenceNr() int64 {
	if m != nil {
		return m.FromSequenceNr
	}
	return 0
}

// The highest Sequence Number found for the provided request
type ReadHighestSequenceNrResponse struct {
	// The sequence number of the latest event
	ToSequenceNr         int64    `protobuf:"varint,1,opt,name=to_sequence_nr,json=toSequenceNr,proto3" json:"to_sequence_nr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadHighestSequenceNrResponse) Reset()         { *m = ReadHighestSequenceNrResponse{} }
func (m *ReadHighestSequenceNrResponse) String() string { return proto.CompactTextString(m) }
func (*ReadHighestSequenceNrResponse) ProtoMessage()    {}
func (*ReadHighestSequenceNrResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{10}
}

func (m *ReadHighestSequenceNrResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadHighestSequenceNrResponse.Unmarshal(m, b)
}
func (m *ReadHighestSequenceNrResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadHighestSequenceNrResponse.Marshal(b, m, deterministic)
}
func (m *ReadHighestSequenceNrResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadHighestSequenceNrResponse.Merge(m, src)
}
func (m *ReadHighestSequenceNrResponse) XXX_Size() int {
	return xxx_messageInfo_ReadHighestSequenceNrResponse.Size(m)
}
func (m *ReadHighestSequenceNrResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadHighestSequenceNrResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReadHighestSequenceNrResponse proto.InternalMessageInfo

func (m *ReadHighestSequenceNrResponse) GetToSequenceNr() int64 {
	if m != nil {
		return m.ToSequenceNr
	}
	return 0
}

// A confirmation to a request from the client
type Confirmation struct {
	// True when successful, otherwise false
	Success              bool     `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Confirmation) Reset()         { *m = Confirmation{} }
func (m *Confirmation) String() string { return proto.CompactTextString(m) }
func (*Confirmation) ProtoMessage()    {}
func (*Confirmation) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{11}
}

func (m *Confirmation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Confirmation.Unmarshal(m, b)
}
func (m *Confirmation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Confirmation.Marshal(b, m, deterministic)
}
func (m *Confirmation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Confirmation.Merge(m, src)
}
func (m *Confirmation) XXX_Size() int {
	return xxx_messageInfo_Confirmation.Size(m)
}
func (m *Confirmation) XXX_DiscardUnknown() {
	xxx_messageInfo_Confirmation.DiscardUnknown(m)
}

var xxx_messageInfo_Confirmation proto.InternalMessageInfo

func (m *Confirmation) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

// Request describing the desire to read events for a specific Aggregate
type GetAggregateEventsRequest struct {
	// The identifier of the aggregate to read events for
	AggregateId string `protobuf:"bytes,1,opt,name=aggregate_id,json=aggregateId,proto3" json:"aggregate_id,omitempty"`
	// The sequence number of the first event to receive
	InitialSequence int64 `protobuf:"varint,2,opt,name=initial_sequence,json=initialSequence,proto3" json:"initial_sequence,omitempty"`
	// Whether a snapshot may be returned as first element in the stream
	AllowSnapshots       bool     `protobuf:"varint,3,opt,name=allow_snapshots,json=allowSnapshots,proto3" json:"allow_snapshots,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAggregateEventsRequest) Reset()         { *m = GetAggregateEventsRequest{} }
func (m *GetAggregateEventsRequest) String() string { return proto.CompactTextString(m) }
func (*GetAggregateEventsRequest) ProtoMessage()    {}
func (*GetAggregateEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{12}
}

func (m *GetAggregateEventsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetAggregateEventsRequest.Unmarshal(m, b)
}
func (m *GetAggregateEventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetAggregateEventsRequest.Marshal(b, m, deterministic)
}
func (m *GetAggregateEventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAggregateEventsRequest.Merge(m, src)
}
func (m *GetAggregateEventsRequest) XXX_Size() int {
	return xxx_messageInfo_GetAggregateEventsRequest.Size(m)
}
func (m *GetAggregateEventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAggregateEventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAggregateEventsRequest proto.InternalMessageInfo

func (m *GetAggregateEventsRequest) GetAggregateId() string {
	if m != nil {
		return m.AggregateId
	}
	return ""
}

func (m *GetAggregateEventsRequest) GetInitialSequence() int64 {
	if m != nil {
		return m.InitialSequence
	}
	return 0
}

func (m *GetAggregateEventsRequest) GetAllowSnapshots() bool {
	if m != nil {
		return m.AllowSnapshots
	}
	return false
}

// Request message to retrieve Snapshot Events for a specific Aggregate instance
type GetAggregateSnapshotsRequest struct {
	// The identifier to fetch the snapshots for
	AggregateId string `protobuf:"bytes,1,opt,name=aggregate_id,json=aggregateId,proto3" json:"aggregate_id,omitempty"`
	// The minimal sequence number of the snapshots to retrieve
	InitialSequence int64 `protobuf:"varint,2,opt,name=initial_sequence,json=initialSequence,proto3" json:"initial_sequence,omitempty"`
	// The maximum sequence number of the snapshots to retrieve
	MaxSequence int64 `protobuf:"varint,3,opt,name=max_sequence,json=maxSequence,proto3" json:"max_sequence,omitempty"`
	// The maximum number of results to stream
	MaxResults           int32    `protobuf:"varint,4,opt,name=max_results,json=maxResults,proto3" json:"max_results,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAggregateSnapshotsRequest) Reset()         { *m = GetAggregateSnapshotsRequest{} }
func (m *GetAggregateSnapshotsRequest) String() string { return proto.CompactTextString(m) }
func (*GetAggregateSnapshotsRequest) ProtoMessage()    {}
func (*GetAggregateSnapshotsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{13}
}

func (m *GetAggregateSnapshotsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetAggregateSnapshotsRequest.Unmarshal(m, b)
}
func (m *GetAggregateSnapshotsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetAggregateSnapshotsRequest.Marshal(b, m, deterministic)
}
func (m *GetAggregateSnapshotsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAggregateSnapshotsRequest.Merge(m, src)
}
func (m *GetAggregateSnapshotsRequest) XXX_Size() int {
	return xxx_messageInfo_GetAggregateSnapshotsRequest.Size(m)
}
func (m *GetAggregateSnapshotsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAggregateSnapshotsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAggregateSnapshotsRequest proto.InternalMessageInfo

func (m *GetAggregateSnapshotsRequest) GetAggregateId() string {
	if m != nil {
		return m.AggregateId
	}
	return ""
}

func (m *GetAggregateSnapshotsRequest) GetInitialSequence() int64 {
	if m != nil {
		return m.InitialSequence
	}
	return 0
}

func (m *GetAggregateSnapshotsRequest) GetMaxSequence() int64 {
	if m != nil {
		return m.MaxSequence
	}
	return 0
}

func (m *GetAggregateSnapshotsRequest) GetMaxResults() int32 {
	if m != nil {
		return m.MaxResults
	}
	return 0
}

// Request message to open an Event Stream from the Event Store.
type GetEventsRequest struct {
	// The token to start streaming from
	TrackingToken int64 `protobuf:"varint,1,opt,name=tracking_token,json=trackingToken,proto3" json:"tracking_token,omitempty"`
	// The number of messages the server may send before it needs to wait for more permits
	NumberOfPermits int64 `protobuf:"varint,2,opt,name=number_of_permits,json=numberOfPermits,proto3" json:"number_of_permits,omitempty"`
	// The unique identifier of this client instance. Used for monitoring.
	ClientId string `protobuf:"bytes,3,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// The component name of this client instance. Used for monitoring.
	ComponentName string `protobuf:"bytes,4,opt,name=component_name,json=componentName,proto3" json:"component_name,omitempty"`
	// The name of the processor requesting this stream. Used for monitoring.
	Processor string `protobuf:"bytes,5,opt,name=processor,proto3" json:"processor,omitempty"`
	// An enumeration of payload types that need to be blacklisted. The Server will stop sending messages of these
	//types in order to reduce I/O. Note that the Server may occasionally send a blacklisted message to prevent
	//time-outs and stale tokens on clients.
	Blacklist            []*PayloadDescription `protobuf:"bytes,6,rep,name=blacklist,proto3" json:"blacklist,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *GetEventsRequest) Reset()         { *m = GetEventsRequest{} }
func (m *GetEventsRequest) String() string { return proto.CompactTextString(m) }
func (*GetEventsRequest) ProtoMessage()    {}
func (*GetEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{14}
}

func (m *GetEventsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetEventsRequest.Unmarshal(m, b)
}
func (m *GetEventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetEventsRequest.Marshal(b, m, deterministic)
}
func (m *GetEventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetEventsRequest.Merge(m, src)
}
func (m *GetEventsRequest) XXX_Size() int {
	return xxx_messageInfo_GetEventsRequest.Size(m)
}
func (m *GetEventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetEventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetEventsRequest proto.InternalMessageInfo

func (m *GetEventsRequest) GetTrackingToken() int64 {
	if m != nil {
		return m.TrackingToken
	}
	return 0
}

func (m *GetEventsRequest) GetNumberOfPermits() int64 {
	if m != nil {
		return m.NumberOfPermits
	}
	return 0
}

func (m *GetEventsRequest) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *GetEventsRequest) GetComponentName() string {
	if m != nil {
		return m.ComponentName
	}
	return ""
}

func (m *GetEventsRequest) GetProcessor() string {
	if m != nil {
		return m.Processor
	}
	return ""
}

func (m *GetEventsRequest) GetBlacklist() []*PayloadDescription {
	if m != nil {
		return m.Blacklist
	}
	return nil
}

// Message containing the information of an Event
type Event struct {
	// The unique identifier of this event
	MessageIdentifier string `protobuf:"bytes,1,opt,name=message_identifier,json=messageIdentifier,proto3" json:"message_identifier,omitempty"`
	// The identifier of the Aggregate instance that published this event, if any
	AggregateIdentifier string `protobuf:"bytes,2,opt,name=aggregate_identifier,json=aggregateIdentifier,proto3" json:"aggregate_identifier,omitempty"`
	// The sequence number of the Event in the Aggregate instance that published it, if any
	AggregateSequenceNumber int64 `protobuf:"varint,3,opt,name=aggregate_sequence_number,json=aggregateSequenceNumber,proto3" json:"aggregate_sequence_number,omitempty"`
	// The Type of the Aggregate instance that published this Event, if any
	AggregateType string `protobuf:"bytes,4,opt,name=aggregate_type,json=aggregateType,proto3" json:"aggregate_type,omitempty"`
	// The timestamp of the Event
	Timestamp int64 `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// The Payload of the Event
	Payload *SerializedObject `protobuf:"bytes,6,opt,name=payload,proto3" json:"payload,omitempty"`
	// The Meta Data of the Event
	MetaData map[string]*MetaDataValue `protobuf:"bytes,7,rep,name=meta_data,json=metaData,proto3" json:"meta_data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Flag indicating whether the Event is a snapshot Event
	Snapshot             bool     `protobuf:"varint,8,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{15}
}

func (m *Event) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event.Unmarshal(m, b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event.Marshal(b, m, deterministic)
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return xxx_messageInfo_Event.Size(m)
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetMessageIdentifier() string {
	if m != nil {
		return m.MessageIdentifier
	}
	return ""
}

func (m *Event) GetAggregateIdentifier() string {
	if m != nil {
		return m.AggregateIdentifier
	}
	return ""
}

func (m *Event) GetAggregateSequenceNumber() int64 {
	if m != nil {
		return m.AggregateSequenceNumber
	}
	return 0
}

func (m *Event) GetAggregateType() string {
	if m != nil {
		return m.AggregateType
	}
	return ""
}

func (m *Event) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Event) GetPayload() *SerializedObject {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Event) GetMetaData() map[string]*MetaDataValue {
	if m != nil {
		return m.MetaData
	}
	return nil
}

func (m *Event) GetSnapshot() bool {
	if m != nil {
		return m.Snapshot
	}
	return false
}

// Value used in Query Responses to represent a value in its original type
type QueryValue struct {
	// The actual value, which can be one of string, 64 bit signed integer, boolean or 64 bits floating point
	//
	// Types that are valid to be assigned to Data:
	//	*QueryValue_TextValue
	//	*QueryValue_NumberValue
	//	*QueryValue_BooleanValue
	//	*QueryValue_DoubleValue
	Data                 isQueryValue_Data `protobuf_oneof:"data"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *QueryValue) Reset()         { *m = QueryValue{} }
func (m *QueryValue) String() string { return proto.CompactTextString(m) }
func (*QueryValue) ProtoMessage()    {}
func (*QueryValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{16}
}

func (m *QueryValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryValue.Unmarshal(m, b)
}
func (m *QueryValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryValue.Marshal(b, m, deterministic)
}
func (m *QueryValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryValue.Merge(m, src)
}
func (m *QueryValue) XXX_Size() int {
	return xxx_messageInfo_QueryValue.Size(m)
}
func (m *QueryValue) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryValue.DiscardUnknown(m)
}

var xxx_messageInfo_QueryValue proto.InternalMessageInfo

type isQueryValue_Data interface {
	isQueryValue_Data()
}

type QueryValue_TextValue struct {
	TextValue string `protobuf:"bytes,1,opt,name=text_value,json=textValue,proto3,oneof"`
}

type QueryValue_NumberValue struct {
	NumberValue int64 `protobuf:"zigzag64,2,opt,name=number_value,json=numberValue,proto3,oneof"`
}

type QueryValue_BooleanValue struct {
	BooleanValue bool `protobuf:"varint,3,opt,name=boolean_value,json=booleanValue,proto3,oneof"`
}

type QueryValue_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,4,opt,name=double_value,json=doubleValue,proto3,oneof"`
}

func (*QueryValue_TextValue) isQueryValue_Data() {}

func (*QueryValue_NumberValue) isQueryValue_Data() {}

func (*QueryValue_BooleanValue) isQueryValue_Data() {}

func (*QueryValue_DoubleValue) isQueryValue_Data() {}

func (m *QueryValue) GetData() isQueryValue_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *QueryValue) GetTextValue() string {
	if x, ok := m.GetData().(*QueryValue_TextValue); ok {
		return x.TextValue
	}
	return ""
}

func (m *QueryValue) GetNumberValue() int64 {
	if x, ok := m.GetData().(*QueryValue_NumberValue); ok {
		return x.NumberValue
	}
	return 0
}

func (m *QueryValue) GetBooleanValue() bool {
	if x, ok := m.GetData().(*QueryValue_BooleanValue); ok {
		return x.BooleanValue
	}
	return false
}

func (m *QueryValue) GetDoubleValue() float64 {
	if x, ok := m.GetData().(*QueryValue_DoubleValue); ok {
		return x.DoubleValue
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*QueryValue) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*QueryValue_TextValue)(nil),
		(*QueryValue_NumberValue)(nil),
		(*QueryValue_BooleanValue)(nil),
		(*QueryValue_DoubleValue)(nil),
	}
}

// Description of a Payload Type
type PayloadDescription struct {
	// The type identifier of the Payload
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// The revision of the Payload Type
	Revision             string   `protobuf:"bytes,2,opt,name=revision,proto3" json:"revision,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PayloadDescription) Reset()         { *m = PayloadDescription{} }
func (m *PayloadDescription) String() string { return proto.CompactTextString(m) }
func (*PayloadDescription) ProtoMessage()    {}
func (*PayloadDescription) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d17a9d3f0ddf27e, []int{17}
}

func (m *PayloadDescription) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PayloadDescription.Unmarshal(m, b)
}
func (m *PayloadDescription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PayloadDescription.Marshal(b, m, deterministic)
}
func (m *PayloadDescription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadDescription.Merge(m, src)
}
func (m *PayloadDescription) XXX_Size() int {
	return xxx_messageInfo_PayloadDescription.Size(m)
}
func (m *PayloadDescription) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadDescription.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadDescription proto.InternalMessageInfo

func (m *PayloadDescription) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PayloadDescription) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func init() {
	proto.RegisterType((*GetFirstTokenRequest)(nil), "io.axoniq.axonserver.grpc.event.GetFirstTokenRequest")
	proto.RegisterType((*GetLastTokenRequest)(nil), "io.axoniq.axonserver.grpc.event.GetLastTokenRequest")
	proto.RegisterType((*GetTokenAtRequest)(nil), "io.axoniq.axonserver.grpc.event.GetTokenAtRequest")
	proto.RegisterType((*TrackingToken)(nil), "io.axoniq.axonserver.grpc.event.TrackingToken")
	proto.RegisterType((*EventWithToken)(nil), "io.axoniq.axonserver.grpc.event.EventWithToken")
	proto.RegisterType((*QueryEventsRequest)(nil), "io.axoniq.axonserver.grpc.event.QueryEventsRequest")
	proto.RegisterType((*QueryEventsResponse)(nil), "io.axoniq.axonserver.grpc.event.QueryEventsResponse")
	proto.RegisterType((*ColumnsResponse)(nil), "io.axoniq.axonserver.grpc.event.ColumnsResponse")
	proto.RegisterType((*RowResponse)(nil), "io.axoniq.axonserver.grpc.event.RowResponse")
	proto.RegisterMapType((map[string]*QueryValue)(nil), "io.axoniq.axonserver.grpc.event.RowResponse.ValuesEntry")
	proto.RegisterType((*ReadHighestSequenceNrRequest)(nil), "io.axoniq.axonserver.grpc.event.ReadHighestSequenceNrRequest")
	proto.RegisterType((*ReadHighestSequenceNrResponse)(nil), "io.axoniq.axonserver.grpc.event.ReadHighestSequenceNrResponse")
	proto.RegisterType((*Confirmation)(nil), "io.axoniq.axonserver.grpc.event.Confirmation")
	proto.RegisterType((*GetAggregateEventsRequest)(nil), "io.axoniq.axonserver.grpc.event.GetAggregateEventsRequest")
	proto.RegisterType((*GetAggregateSnapshotsRequest)(nil), "io.axoniq.axonserver.grpc.event.GetAggregateSnapshotsRequest")
	proto.RegisterType((*GetEventsRequest)(nil), "io.axoniq.axonserver.grpc.event.GetEventsRequest")
	proto.RegisterType((*Event)(nil), "io.axoniq.axonserver.grpc.event.Event")
	proto.RegisterMapType((map[string]*MetaDataValue)(nil), "io.axoniq.axonserver.grpc.event.Event.MetaDataEntry")
	proto.RegisterType((*QueryValue)(nil), "io.axoniq.axonserver.grpc.event.QueryValue")
	proto.RegisterType((*PayloadDescription)(nil), "io.axoniq.axonserver.grpc.event.PayloadDescription")
}

func init() {
	proto.RegisterFile("event.proto", fileDescriptor_2d17a9d3f0ddf27e)
}

var fileDescriptor_2d17a9d3f0ddf27e = []byte{
	// 1304 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xdf, 0x6e, 0x13, 0x47,
	0x17, 0xf7, 0xda, 0x71, 0x62, 0x9f, 0x75, 0x9c, 0x30, 0x09, 0x7c, 0xc6, 0x5f, 0xaa, 0x84, 0x6d,
	0x69, 0x4d, 0x5b, 0x1c, 0x08, 0x54, 0x42, 0xa8, 0x45, 0x0d, 0x90, 0xc6, 0x48, 0x29, 0x84, 0x0d,
	0x6a, 0xab, 0xde, 0x58, 0x93, 0xdd, 0xb1, 0x33, 0xcd, 0xee, 0xce, 0x32, 0x33, 0x76, 0x92, 0x4a,
	0xed, 0x4d, 0x2f, 0xb8, 0xef, 0x55, 0xd5, 0x07, 0xe8, 0x75, 0xdf, 0x88, 0x57, 0xa9, 0x66, 0x66,
	0x77, 0xed, 0x0d, 0x10, 0xdb, 0x48, 0x5c, 0xd9, 0xf3, 0xdb, 0x73, 0x7e, 0xe7, 0xdf, 0x9c, 0x33,
	0x33, 0x60, 0x93, 0x21, 0x89, 0x64, 0x3b, 0xe6, 0x4c, 0x32, 0xb4, 0x4e, 0x59, 0x1b, 0x9f, 0xb2,
	0x88, 0xbe, 0xd4, 0x3f, 0x82, 0xf0, 0x21, 0xe1, 0xed, 0x3e, 0x8f, 0xbd, 0xb6, 0x16, 0x6b, 0xd6,
	0x3c, 0x16, 0x86, 0x2c, 0x32, 0xe2, 0xce, 0x15, 0x58, 0xdd, 0x25, 0xf2, 0x3b, 0xca, 0x85, 0x7c,
	0xc1, 0x8e, 0x49, 0xe4, 0x92, 0x97, 0x03, 0x22, 0xa4, 0x73, 0x19, 0x56, 0x76, 0x89, 0xdc, 0xc3,
	0xe7, 0xe0, 0x9b, 0x70, 0x69, 0x97, 0x18, 0x68, 0x5b, 0x26, 0x20, 0x6a, 0xc0, 0x02, 0x8d, 0x84,
	0xc4, 0x91, 0x6c, 0x58, 0x1b, 0x56, 0xab, 0xe4, 0xa6, 0x4b, 0xe7, 0x3a, 0x2c, 0xbe, 0xe0, 0xd8,
	0x3b, 0xa6, 0x51, 0x5f, 0xeb, 0xa0, 0x55, 0x28, 0x4b, 0xf5, 0x27, 0x11, 0x34, 0x0b, 0xc7, 0x87,
	0xfa, 0x8e, 0xf2, 0xed, 0x47, 0x2a, 0x8f, 0x2e, 0x90, 0x43, 0x5f, 0x43, 0x59, 0xc7, 0xd0, 0x28,
	0x6e, 0x58, 0x2d, 0x7b, 0xeb, 0xd3, 0xf6, 0x84, 0x58, 0xdb, 0x9a, 0xd5, 0x35, 0x4a, 0xce, 0x09,
	0xa0, 0xe7, 0x03, 0xc2, 0xcf, 0x34, 0x28, 0x52, 0xe7, 0x57, 0xa1, 0xfc, 0x52, 0xa1, 0xda, 0x52,
	0xd5, 0x35, 0x0b, 0xf4, 0x39, 0x5c, 0x8a, 0x06, 0xe1, 0x21, 0xe1, 0x5d, 0xd6, 0xeb, 0xc6, 0x84,
	0x87, 0x54, 0x0a, 0x6d, 0xb5, 0xe4, 0x2e, 0x99, 0x0f, 0xcf, 0x7a, 0xfb, 0x06, 0x46, 0xeb, 0x60,
	0x07, 0x74, 0x48, 0xba, 0xda, 0x8a, 0x68, 0x94, 0x36, 0xac, 0x56, 0xc5, 0x05, 0x05, 0x19, 0x4b,
	0xce, 0xab, 0x22, 0xac, 0xe4, 0x2c, 0x8b, 0x58, 0x39, 0x8b, 0xf6, 0x60, 0xc1, 0x63, 0xc1, 0x20,
	0x8c, 0x84, 0x36, 0x6e, 0x6f, 0xdd, 0x9a, 0x18, 0xd0, 0x23, 0x23, 0x9f, 0x52, 0x74, 0x0a, 0x6e,
	0x4a, 0x81, 0xbe, 0x85, 0x12, 0x67, 0x27, 0x49, 0x6a, 0xbe, 0x9c, 0xc8, 0xe4, 0xb2, 0x93, 0x31,
	0x16, 0xa5, 0x8a, 0x7e, 0x82, 0xa5, 0x1e, 0x0d, 0x88, 0xe8, 0x7a, 0x2c, 0x8c, 0x03, 0x22, 0x89,
	0xaf, 0x83, 0xb1, 0xb7, 0x6e, 0x4e, 0xe1, 0x57, 0xd4, 0xa3, 0x3c, 0xc4, 0x92, 0xb2, 0xa8, 0x53,
	0x70, 0xeb, 0x9a, 0xe7, 0x51, 0x4a, 0xf3, 0x70, 0x1e, 0xe6, 0x7c, 0x2c, 0xb1, 0x73, 0x03, 0x96,
	0xce, 0x45, 0x80, 0xae, 0xc0, 0xbc, 0x89, 0xa0, 0x61, 0x6d, 0x94, 0x5a, 0x55, 0x37, 0x59, 0x39,
	0xaf, 0x8b, 0x60, 0x8f, 0xf9, 0x88, 0x3a, 0x50, 0xa5, 0x7e, 0x77, 0x88, 0x83, 0x01, 0x11, 0x5a,
	0xd4, 0xde, 0xfa, 0x62, 0xa2, 0x5b, 0x3a, 0xeb, 0x3f, 0x28, 0x1d, 0xb7, 0x42, 0x7d, 0xfd, 0x47,
	0xa0, 0x3d, 0xb0, 0x05, 0xe3, 0x32, 0xe5, 0x2a, 0xce, 0xce, 0x05, 0x4a, 0x3f, 0x61, 0xdb, 0x87,
	0xf9, 0x84, 0xa8, 0xa4, 0x89, 0xee, 0xcd, 0x92, 0xf9, 0xb6, 0x21, 0xd9, 0x89, 0x24, 0x3f, 0x73,
	0x13, 0x9e, 0x66, 0x0f, 0xec, 0x31, 0x18, 0x2d, 0x43, 0xe9, 0x98, 0xa4, 0xdb, 0x53, 0xfd, 0x45,
	0xdb, 0x50, 0xd6, 0xa2, 0x49, 0xad, 0x67, 0x72, 0xdd, 0x68, 0xde, 0x2f, 0xde, 0xb3, 0x9c, 0x63,
	0x58, 0x73, 0x09, 0xf6, 0x3b, 0xb4, 0x7f, 0x44, 0x84, 0x3c, 0x50, 0xfd, 0x10, 0x79, 0xe4, 0x29,
	0x4f, 0x3b, 0xe3, 0x1a, 0xd4, 0x70, 0xbf, 0xcf, 0x49, 0x1f, 0x4b, 0xd2, 0xa5, 0x7e, 0xe2, 0x81,
	0x9d, 0x61, 0x4f, 0x7c, 0xd4, 0x82, 0xe5, 0x1e, 0x67, 0x61, 0x57, 0x24, 0xca, 0xdd, 0x88, 0xeb,
	0x2d, 0x53, 0x72, 0xeb, 0x0a, 0x1f, 0x71, 0x3a, 0x3b, 0xf0, 0xd1, 0x3b, 0x8c, 0x25, 0xf5, 0xfd,
	0x04, 0xea, 0x92, 0xe5, 0x88, 0x4c, 0xeb, 0xd7, 0x24, 0x1b, 0xa3, 0x69, 0x41, 0x6d, 0x7c, 0xab,
	0xa9, 0xd1, 0x23, 0x06, 0x9e, 0x47, 0x84, 0x69, 0xa1, 0x8a, 0x9b, 0x2e, 0x9d, 0x3f, 0x2d, 0xb8,
	0xba, 0x4b, 0xe4, 0x76, 0xea, 0x6d, 0xbe, 0xeb, 0xa7, 0x88, 0xed, 0x06, 0x2c, 0xd3, 0x88, 0x4a,
	0x8a, 0x83, 0xcc, 0xab, 0x74, 0x02, 0x24, 0x78, 0xea, 0x17, 0xfa, 0x0c, 0x96, 0x70, 0x10, 0xb0,
	0x93, 0xae, 0x88, 0x70, 0x2c, 0x8e, 0x58, 0x36, 0x05, 0xea, 0x1a, 0x3e, 0x48, 0x51, 0xe7, 0x5f,
	0x0b, 0xd6, 0xc6, 0x9d, 0xca, 0xbe, 0x7c, 0x18, 0xbf, 0xae, 0x41, 0x2d, 0xc4, 0xa7, 0x23, 0x31,
	0x53, 0x1a, 0x3b, 0xc4, 0xa7, 0x99, 0xc8, 0x3a, 0xa8, 0x65, 0x97, 0x13, 0x31, 0x08, 0xa4, 0x68,
	0xcc, 0x6d, 0x58, 0xad, 0xb2, 0x0b, 0x21, 0x3e, 0x75, 0x0d, 0xe2, 0xfc, 0x5d, 0x84, 0xe5, 0x5d,
	0x22, 0xf3, 0xe9, 0xbb, 0x0e, 0x75, 0x99, 0xcc, 0xf5, 0xee, 0xf8, 0x9c, 0x5e, 0x94, 0xb9, 0x69,
	0x3f, 0xcb, 0x14, 0xfd, 0x3f, 0x54, 0xbd, 0x80, 0x92, 0x48, 0xaa, 0xb0, 0x4b, 0x3a, 0xec, 0x8a,
	0x01, 0x9e, 0xf8, 0xca, 0x9e, 0x9a, 0x49, 0x2c, 0x52, 0xdf, 0x23, 0x1c, 0x12, 0xed, 0x68, 0xd5,
	0x5d, 0xcc, 0xd0, 0xa7, 0x38, 0x24, 0x68, 0x0d, 0xaa, 0x31, 0x67, 0xaa, 0xfc, 0x8c, 0x37, 0xca,
	0x5a, 0x62, 0x04, 0xa0, 0xe7, 0x50, 0x3d, 0x0c, 0xb0, 0x77, 0x1c, 0x50, 0x21, 0x1b, 0xf3, 0xba,
	0x59, 0xef, 0x4c, 0x6c, 0x9d, 0x7d, 0x7c, 0x16, 0x30, 0xec, 0x3f, 0x26, 0xc2, 0xe3, 0x34, 0x56,
	0x7b, 0xce, 0x1d, 0xb1, 0x38, 0xaf, 0xe6, 0xa0, 0xac, 0x33, 0x83, 0x6e, 0x02, 0x0a, 0x89, 0x10,
	0xb8, 0xaf, 0xca, 0x46, 0x22, 0x49, 0x7b, 0x94, 0xf0, 0xa4, 0x7c, 0x97, 0x92, 0x2f, 0x4f, 0xb2,
	0x0f, 0xe8, 0x36, 0xac, 0x8e, 0xd7, 0x39, 0x53, 0x28, 0x6a, 0x85, 0x95, 0xb1, 0x7a, 0x67, 0x2a,
	0xf7, 0xe1, 0xea, 0x48, 0x65, 0xd4, 0x27, 0x3a, 0x8d, 0x49, 0x65, 0xff, 0x97, 0x09, 0x64, 0x2d,
	0xa3, 0x3f, 0xab, 0xfc, 0x8d, 0x74, 0xe5, 0x59, 0x9c, 0xe5, 0x2f, 0x43, 0x5f, 0x9c, 0xc5, 0x3a,
	0x7f, 0x92, 0x86, 0x44, 0x48, 0x1c, 0xc6, 0x3a, 0x7f, 0x25, 0x77, 0x04, 0xa0, 0x1d, 0x58, 0x88,
	0x4d, 0x36, 0x1a, 0xf3, 0x13, 0x07, 0xcf, 0x01, 0xe1, 0x14, 0x07, 0xf4, 0x57, 0xe2, 0x3f, 0x3b,
	0xfc, 0x85, 0x78, 0xd2, 0x4d, 0x75, 0x55, 0x19, 0x42, 0x22, 0x71, 0x57, 0x1d, 0x08, 0x8d, 0x05,
	0x5d, 0x86, 0xbb, 0xd3, 0x1d, 0xe4, 0xed, 0xef, 0x89, 0xc4, 0x8f, 0xb1, 0xc4, 0x66, 0x5e, 0x56,
	0xc2, 0x64, 0x89, 0x9a, 0x50, 0x49, 0x3b, 0xaf, 0x51, 0xd1, 0x8d, 0x97, 0xad, 0x9b, 0x04, 0x16,
	0x73, 0x6a, 0x6f, 0x99, 0xa7, 0x0f, 0xf2, 0xf3, 0xb4, 0x75, 0x81, 0x37, 0x29, 0xd5, 0x1b, 0xc3,
	0xf4, 0x1f, 0x0b, 0x60, 0x34, 0x66, 0xd1, 0x3a, 0x80, 0x24, 0xa7, 0xc9, 0x19, 0x63, 0x6c, 0x75,
	0x0a, 0x6e, 0x55, 0x61, 0x46, 0xe0, 0x63, 0xa8, 0x25, 0xad, 0x31, 0x32, 0x8d, 0x3a, 0x05, 0xd7,
	0x36, 0xa8, 0x11, 0xba, 0x0e, 0x8b, 0x87, 0x8c, 0x05, 0x04, 0x47, 0x89, 0x94, 0x9e, 0x2a, 0x9d,
	0x82, 0x5b, 0x4b, 0xe0, 0x8c, 0xcb, 0x67, 0x83, 0xc3, 0x80, 0x24, 0x52, 0xaa, 0xb6, 0x96, 0xe2,
	0x32, 0xa8, 0x16, 0xca, 0x8e, 0xe0, 0xc7, 0x80, 0xde, 0xdc, 0xd3, 0x08, 0xc1, 0x9c, 0xde, 0x16,
	0x26, 0x2b, 0xfa, 0xbf, 0xca, 0x2a, 0x27, 0x43, 0x2a, 0x28, 0x8b, 0x92, 0x7d, 0x99, 0xad, 0xb7,
	0x5e, 0x57, 0x01, 0x74, 0x4d, 0x0e, 0x24, 0xe3, 0x04, 0x1d, 0x81, 0xbd, 0x1d, 0xc7, 0x24, 0xf2,
	0x4d, 0x33, 0x4c, 0x79, 0x31, 0x6b, 0xce, 0x76, 0xaf, 0x70, 0x0a, 0x2d, 0x0b, 0x51, 0xa8, 0x1b,
	0x4b, 0xe9, 0xe8, 0xfc, 0x60, 0xc6, 0xd0, 0x6f, 0xb0, 0xb2, 0x47, 0xc5, 0xf9, 0x13, 0x04, 0xdd,
	0x9f, 0xc8, 0xf3, 0xce, 0x63, 0xa7, 0x39, 0xa5, 0xaf, 0x4e, 0xe1, 0x96, 0x85, 0xfe, 0xb0, 0xe0,
	0x4a, 0xce, 0x7e, 0x76, 0x58, 0xa0, 0x6f, 0x66, 0x72, 0xe1, 0xfc, 0x21, 0x33, 0x93, 0x17, 0x43,
	0x00, 0xe5, 0x44, 0x12, 0xfb, 0xed, 0x69, 0x0c, 0xe7, 0x43, 0xde, 0x9c, 0xce, 0x58, 0x76, 0xf5,
	0x57, 0x55, 0xbe, 0x65, 0xa1, 0xbf, 0x2c, 0xb8, 0xfc, 0xd6, 0x0b, 0xc3, 0x14, 0xc1, 0x5f, 0x74,
	0xab, 0x69, 0x3e, 0x78, 0x5f, 0x75, 0x73, 0x4f, 0x71, 0x0a, 0xe8, 0x77, 0xb0, 0xc7, 0x6e, 0xf3,
	0xe8, 0xce, 0x74, 0xd7, 0xaf, 0x7c, 0x56, 0xee, 0xce, 0xa6, 0x94, 0xda, 0xd6, 0xa9, 0x39, 0x85,
	0xc5, 0xdc, 0x93, 0x0d, 0x7d, 0x35, 0x4d, 0x55, 0xde, 0x78, 0xe2, 0x35, 0xdb, 0x13, 0xd5, 0x72,
	0x6f, 0x37, 0xa7, 0x80, 0x86, 0x50, 0x1b, 0x7f, 0x14, 0xa2, 0xbb, 0xd3, 0x18, 0x3e, 0xff, 0x86,
	0x7c, 0x0f, 0xbb, 0x1c, 0x60, 0xf4, 0xea, 0x44, 0x5b, 0xd3, 0x58, 0xcd, 0x3f, 0x51, 0x67, 0xb7,
	0xf9, 0x70, 0x6d, 0xdf, 0xfa, 0xb9, 0x21, 0xb8, 0xb7, 0x19, 0x1f, 0xf7, 0x37, 0x95, 0xdc, 0xa6,
	0xd2, 0xeb, 0x1a, 0xc5, 0xc3, 0x79, 0xfd, 0x7a, 0xbe, 0xf3, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x10, 0x40, 0x5d, 0xd4, 0x7b, 0x0f, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// EventStoreClient is the client API for EventStore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EventStoreClient interface {
	// Accepts a stream of Events returning a Confirmation when completed.
	AppendEvent(ctx context.Context, opts ...grpc.CallOption) (EventStore_AppendEventClient, error)
	// Accepts a Snapshot event returning a Confirmation when completed.
	AppendSnapshot(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Confirmation, error)
	// Retrieves the Events for a given aggregate. Results are streamed rather than returned at once.
	ListAggregateEvents(ctx context.Context, in *GetAggregateEventsRequest, opts ...grpc.CallOption) (EventStore_ListAggregateEventsClient, error)
	// Retrieves the Snapshots for a given aggregate. Results are streamed rather than returned at once.
	ListAggregateSnapshots(ctx context.Context, in *GetAggregateSnapshotsRequest, opts ...grpc.CallOption) (EventStore_ListAggregateSnapshotsClient, error)
	// Retrieves the Events from a given tracking token. Results are streamed rather than returned at once.
	ListEvents(ctx context.Context, opts ...grpc.CallOption) (EventStore_ListEventsClient, error)
	// Gets the highest sequence number for a specific aggregate.
	ReadHighestSequenceNr(ctx context.Context, in *ReadHighestSequenceNrRequest, opts ...grpc.CallOption) (*ReadHighestSequenceNrResponse, error)
	// Performs a query on the event store, returns a stream of results. Input is a stream to allow flow control from the
	// client
	QueryEvents(ctx context.Context, opts ...grpc.CallOption) (EventStore_QueryEventsClient, error)
	// Retrieves the first token available in event store (typically 0). Returns 0 when no events in store.
	GetFirstToken(ctx context.Context, in *GetFirstTokenRequest, opts ...grpc.CallOption) (*TrackingToken, error)
	// Retrieves the last committed token in event store. Returns -1 when no events in store.
	GetLastToken(ctx context.Context, in *GetLastTokenRequest, opts ...grpc.CallOption) (*TrackingToken, error)
	// Retrieves the token of the first token of an event from specified time in event store. Returns -1 when no events in store.
	GetTokenAt(ctx context.Context, in *GetTokenAtRequest, opts ...grpc.CallOption) (*TrackingToken, error)
}

type eventStoreClient struct {
	cc grpc.ClientConnInterface
}

func NewEventStoreClient(cc grpc.ClientConnInterface) EventStoreClient {
	return &eventStoreClient{cc}
}

func (c *eventStoreClient) AppendEvent(ctx context.Context, opts ...grpc.CallOption) (EventStore_AppendEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EventStore_serviceDesc.Streams[0], "/io.axoniq.axonserver.grpc.event.EventStore/AppendEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventStoreAppendEventClient{stream}
	return x, nil
}

type EventStore_AppendEventClient interface {
	Send(*Event) error
	CloseAndRecv() (*Confirmation, error)
	grpc.ClientStream
}

type eventStoreAppendEventClient struct {
	grpc.ClientStream
}

func (x *eventStoreAppendEventClient) Send(m *Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *eventStoreAppendEventClient) CloseAndRecv() (*Confirmation, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Confirmation)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventStoreClient) AppendSnapshot(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Confirmation, error) {
	out := new(Confirmation)
	err := c.cc.Invoke(ctx, "/io.axoniq.axonserver.grpc.event.EventStore/AppendSnapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventStoreClient) ListAggregateEvents(ctx context.Context, in *GetAggregateEventsRequest, opts ...grpc.CallOption) (EventStore_ListAggregateEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EventStore_serviceDesc.Streams[1], "/io.axoniq.axonserver.grpc.event.EventStore/ListAggregateEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventStoreListAggregateEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventStore_ListAggregateEventsClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type eventStoreListAggregateEventsClient struct {
	grpc.ClientStream
}

func (x *eventStoreListAggregateEventsClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventStoreClient) ListAggregateSnapshots(ctx context.Context, in *GetAggregateSnapshotsRequest, opts ...grpc.CallOption) (EventStore_ListAggregateSnapshotsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EventStore_serviceDesc.Streams[2], "/io.axoniq.axonserver.grpc.event.EventStore/ListAggregateSnapshots", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventStoreListAggregateSnapshotsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventStore_ListAggregateSnapshotsClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type eventStoreListAggregateSnapshotsClient struct {
	grpc.ClientStream
}

func (x *eventStoreListAggregateSnapshotsClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventStoreClient) ListEvents(ctx context.Context, opts ...grpc.CallOption) (EventStore_ListEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EventStore_serviceDesc.Streams[3], "/io.axoniq.axonserver.grpc.event.EventStore/ListEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventStoreListEventsClient{stream}
	return x, nil
}

type EventStore_ListEventsClient interface {
	Send(*GetEventsRequest) error
	Recv() (*EventWithToken, error)
	grpc.ClientStream
}

type eventStoreListEventsClient struct {
	grpc.ClientStream
}

func (x *eventStoreListEventsClient) Send(m *GetEventsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *eventStoreListEventsClient) Recv() (*EventWithToken, error) {
	m := new(EventWithToken)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventStoreClient) ReadHighestSequenceNr(ctx context.Context, in *ReadHighestSequenceNrRequest, opts ...grpc.CallOption) (*ReadHighestSequenceNrResponse, error) {
	out := new(ReadHighestSequenceNrResponse)
	err := c.cc.Invoke(ctx, "/io.axoniq.axonserver.grpc.event.EventStore/ReadHighestSequenceNr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventStoreClient) QueryEvents(ctx context.Context, opts ...grpc.CallOption) (EventStore_QueryEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EventStore_serviceDesc.Streams[4], "/io.axoniq.axonserver.grpc.event.EventStore/QueryEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventStoreQueryEventsClient{stream}
	return x, nil
}

type EventStore_QueryEventsClient interface {
	Send(*QueryEventsRequest) error
	Recv() (*QueryEventsResponse, error)
	grpc.ClientStream
}

type eventStoreQueryEventsClient struct {
	grpc.ClientStream
}

func (x *eventStoreQueryEventsClient) Send(m *QueryEventsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *eventStoreQueryEventsClient) Recv() (*QueryEventsResponse, error) {
	m := new(QueryEventsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventStoreClient) GetFirstToken(ctx context.Context, in *GetFirstTokenRequest, opts ...grpc.CallOption) (*TrackingToken, error) {
	out := new(TrackingToken)
	err := c.cc.Invoke(ctx, "/io.axoniq.axonserver.grpc.event.EventStore/GetFirstToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventStoreClient) GetLastToken(ctx context.Context, in *GetLastTokenRequest, opts ...grpc.CallOption) (*TrackingToken, error) {
	out := new(TrackingToken)
	err := c.cc.Invoke(ctx, "/io.axoniq.axonserver.grpc.event.EventStore/GetLastToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventStoreClient) GetTokenAt(ctx context.Context, in *GetTokenAtRequest, opts ...grpc.CallOption) (*TrackingToken, error) {
	out := new(TrackingToken)
	err := c.cc.Invoke(ctx, "/io.axoniq.axonserver.grpc.event.EventStore/GetTokenAt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventStoreServer is the server API for EventStore service.
type EventStoreServer interface {
	// Accepts a stream of Events returning a Confirmation when completed.
	AppendEvent(EventStore_AppendEventServer) error
	// Accepts a Snapshot event returning a Confirmation when completed.
	AppendSnapshot(context.Context, *Event) (*Confirmation, error)
	// Retrieves the Events for a given aggregate. Results are streamed rather than returned at once.
	ListAggregateEvents(*GetAggregateEventsRequest, EventStore_ListAggregateEventsServer) error
	// Retrieves the Snapshots for a given aggregate. Results are streamed rather than returned at once.
	ListAggregateSnapshots(*GetAggregateSnapshotsRequest, EventStore_ListAggregateSnapshotsServer) error
	// Retrieves the Events from a given tracking token. Results are streamed rather than returned at once.
	ListEvents(EventStore_ListEventsServer) error
	// Gets the highest sequence number for a specific aggregate.
	ReadHighestSequenceNr(context.Context, *ReadHighestSequenceNrRequest) (*ReadHighestSequenceNrResponse, error)
	// Performs a query on the event store, returns a stream of results. Input is a stream to allow flow control from the
	// client
	QueryEvents(EventStore_QueryEventsServer) error
	// Retrieves the first token available in event store (typically 0). Returns 0 when no events in store.
	GetFirstToken(context.Context, *GetFirstTokenRequest) (*TrackingToken, error)
	// Retrieves the last committed token in event store. Returns -1 when no events in store.
	GetLastToken(context.Context, *GetLastTokenRequest) (*TrackingToken, error)
	// Retrieves the token of the first token of an event from specified time in event store. Returns -1 when no events in store.
	GetTokenAt(context.Context, *GetTokenAtRequest) (*TrackingToken, error)
}

// UnimplementedEventStoreServer can be embedded to have forward compatible implementations.
type UnimplementedEventStoreServer struct {
}

func (*UnimplementedEventStoreServer) AppendEvent(srv EventStore_AppendEventServer) error {
	return status.Errorf(codes.Unimplemented, "method AppendEvent not implemented")
}
func (*UnimplementedEventStoreServer) AppendSnapshot(ctx context.Context, req *Event) (*Confirmation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppendSnapshot not implemented")
}
func (*UnimplementedEventStoreServer) ListAggregateEvents(req *GetAggregateEventsRequest, srv EventStore_ListAggregateEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListAggregateEvents not implemented")
}
func (*UnimplementedEventStoreServer) ListAggregateSnapshots(req *GetAggregateSnapshotsRequest, srv EventStore_ListAggregateSnapshotsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListAggregateSnapshots not implemented")
}
func (*UnimplementedEventStoreServer) ListEvents(srv EventStore_ListEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListEvents not implemented")
}
func (*UnimplementedEventStoreServer) ReadHighestSequenceNr(ctx context.Context, req *ReadHighestSequenceNrRequest) (*ReadHighestSequenceNrResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadHighestSequenceNr not implemented")
}
func (*UnimplementedEventStoreServer) QueryEvents(srv EventStore_QueryEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method QueryEvents not implemented")
}
func (*UnimplementedEventStoreServer) GetFirstToken(ctx context.Context, req *GetFirstTokenRequest) (*TrackingToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFirstToken not implemented")
}
func (*UnimplementedEventStoreServer) GetLastToken(ctx context.Context, req *GetLastTokenRequest) (*TrackingToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastToken not implemented")
}
func (*UnimplementedEventStoreServer) GetTokenAt(ctx context.Context, req *GetTokenAtRequest) (*TrackingToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenAt not implemented")
}

func RegisterEventStoreServer(s *grpc.Server, srv EventStoreServer) {
	s.RegisterService(&_EventStore_serviceDesc, srv)
}

func _EventStore_AppendEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EventStoreServer).AppendEvent(&eventStoreAppendEventServer{stream})
}

type EventStore_AppendEventServer interface {
	SendAndClose(*Confirmation) error
	Recv() (*Event, error)
	grpc.ServerStream
}

type eventStoreAppendEventServer struct {
	grpc.ServerStream
}

func (x *eventStoreAppendEventServer) SendAndClose(m *Confirmation) error {
	return x.ServerStream.SendMsg(m)
}

func (x *eventStoreAppendEventServer) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EventStore_AppendSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventStoreServer).AppendSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.axoniq.axonserver.grpc.event.EventStore/AppendSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventStoreServer).AppendSnapshot(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventStore_ListAggregateEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAggregateEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventStoreServer).ListAggregateEvents(m, &eventStoreListAggregateEventsServer{stream})
}

type EventStore_ListAggregateEventsServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type eventStoreListAggregateEventsServer struct {
	grpc.ServerStream
}

func (x *eventStoreListAggregateEventsServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func _EventStore_ListAggregateSnapshots_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAggregateSnapshotsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventStoreServer).ListAggregateSnapshots(m, &eventStoreListAggregateSnapshotsServer{stream})
}

type EventStore_ListAggregateSnapshotsServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type eventStoreListAggregateSnapshotsServer struct {
	grpc.ServerStream
}

func (x *eventStoreListAggregateSnapshotsServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func _EventStore_ListEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EventStoreServer).ListEvents(&eventStoreListEventsServer{stream})
}

type EventStore_ListEventsServer interface {
	Send(*EventWithToken) error
	Recv() (*GetEventsRequest, error)
	grpc.ServerStream
}

type eventStoreListEventsServer struct {
	grpc.ServerStream
}

func (x *eventStoreListEventsServer) Send(m *EventWithToken) error {
	return x.ServerStream.SendMsg(m)
}

func (x *eventStoreListEventsServer) Recv() (*GetEventsRequest, error) {
	m := new(GetEventsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EventStore_ReadHighestSequenceNr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadHighestSequenceNrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventStoreServer).ReadHighestSequenceNr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.axoniq.axonserver.grpc.event.EventStore/ReadHighestSequenceNr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventStoreServer).ReadHighestSequenceNr(ctx, req.(*ReadHighestSequenceNrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventStore_QueryEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EventStoreServer).QueryEvents(&eventStoreQueryEventsServer{stream})
}

type EventStore_QueryEventsServer interface {
	Send(*QueryEventsResponse) error
	Recv() (*QueryEventsRequest, error)
	grpc.ServerStream
}

type eventStoreQueryEventsServer struct {
	grpc.ServerStream
}

func (x *eventStoreQueryEventsServer) Send(m *QueryEventsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *eventStoreQueryEventsServer) Recv() (*QueryEventsRequest, error) {
	m := new(QueryEventsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EventStore_GetFirstToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFirstTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventStoreServer).GetFirstToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.axoniq.axonserver.grpc.event.EventStore/GetFirstToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventStoreServer).GetFirstToken(ctx, req.(*GetFirstTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventStore_GetLastToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLastTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventStoreServer).GetLastToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.axoniq.axonserver.grpc.event.EventStore/GetLastToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventStoreServer).GetLastToken(ctx, req.(*GetLastTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventStore_GetTokenAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenAtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventStoreServer).GetTokenAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.axoniq.axonserver.grpc.event.EventStore/GetTokenAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventStoreServer).GetTokenAt(ctx, req.(*GetTokenAtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _EventStore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.axoniq.axonserver.grpc.event.EventStore",
	HandlerType: (*EventStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AppendSnapshot",
			Handler:    _EventStore_AppendSnapshot_Handler,
		},
		{
			MethodName: "ReadHighestSequenceNr",
			Handler:    _EventStore_ReadHighestSequenceNr_Handler,
		},
		{
			MethodName: "GetFirstToken",
			Handler:    _EventStore_GetFirstToken_Handler,
		},
		{
			MethodName: "GetLastToken",
			Handler:    _EventStore_GetLastToken_Handler,
		},
		{
			MethodName: "GetTokenAt",
			Handler:    _EventStore_GetTokenAt_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AppendEvent",
			Handler:       _EventStore_AppendEvent_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ListAggregateEvents",
			Handler:       _EventStore_ListAggregateEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListAggregateSnapshots",
			Handler:       _EventStore_ListAggregateSnapshots_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListEvents",
			Handler:       _EventStore_ListEvents_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "QueryEvents",
			Handler:       _EventStore_QueryEvents_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "event.proto",
}
